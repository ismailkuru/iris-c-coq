\section{Language}
\label{sec:language}

\subsection{Definitions}

\paragraph{Syntax.}\label{p:type}

The language is a simplified version of C. It consists of \Prim{} (primitives), \Expr{} (expressions), \Type{} (types) and \Val{} (values).

Memory address $l: \Addr \eqdef \vaddr{b}{o}$ where block address $b \in \nat$, offset $o \in \integer^{+}$.

\begin{align*}
    \tau : \Type \bnfdef{}&
        \tyvoid \mid \tynull \mid \tybyte \mid \tyword \mid \typtr{\tau} \mid \tau \times \tau
\\
    v : \Val \bnfdef{}&
        \void \mid \vnull \mid i \in [0, 2^8) \mid i \in [0, 2^{32}) \mid l \mid (v, v)
\\
    p : \Prim \bnfdef{}&
        \pcli \mid \psti
\\
    e : \Expr \bnfdef{}&
       v \mid x \mid e \oplus e \mid \deref{e} \mid \dereft{\tau}{e} \mid \& e \mid \efst{e} \mid \esnd{e} \\&
       \sskip \mid p \mid e \la e \mid \sif{e}{e}{e} \mid \swhile{e}{e}{e} \mid \\&
       \srete{e} \mid \scall{f}{e_1, ..., e_n} \mid e ; e \mid \alloc{\tau}{e}
\\
\end{align*}

The relationship between $\deref{e}$ and $\dereft{\tau}{e}$: The former one is in source,
and the later one is ``instantiated'' with type information and used in inference rules.
It is part of the efforts of removing lexical analysis from core program logic.

Note: the C program is usually more restrictive by differentiating statements and expressions. For simplicity and
expressivity, we merged them together into a coherent expression $\Expr$ without loss of generality.

\paragraph{Program.}

A program is considered to be a set of functions $\Funct$, each identified by its name. Each
function is a triple of return type $\tau_{ret}$, parameter declarations $(x_1 : \tau_1, ...)$,
and function body $e$.

\paragraph{Evaluation Context.}

To make the evaluation order explicit and reusable by the $\text{WP-BIND}$ rule, we define evaluation context.

\begin{align*}
    \ctx : \ectx \eqdef{}&
        \emptyctx \mid \emptyctx \oplus e \mid v \oplus \emptyctx \mid
        \deref{\emptyctx} \mid \& \emptyctx \mid
        \efst{\emptyctx} \mid \esnd{\emptyctx} \mid \\&
        \emptyctx \la e \mid l \la \emptyctx \mid \sif{\emptyctx}{e}{e} \mid \swhile{e}{\emptyctx}{e} \mid \\&
        \srete{\emptyctx} \mid \scall{f}{v_1, ..., \emptyctx, e_1, ...} \mid \alloc{\tau}{\emptyctx} \mid \emptyctx ; e
\end{align*}

\subsection{Semantics}
\paragraph{Model.}

Define continuation $\cont \eqdef [\ctx]$, and stack $\stack \eqdef [\cont]$.

We define byte-size value and memory model:

\[\bval : \byteval \eqdef \mundef \mid i \in [0, 2^8) \mid l_{\{0 \mid 1 \mid 2 \mid 3\}} \mid \vnull\]

We define state $\sigma: \State \eqdef (\text{heap}: [ l \gmapsto \bval ], \text{text}: [x \gmapsto \Funct], \text{stack}: \stack)$,

You may notice the difference between $\Val$ and $\byteval$, it is intentional to create a layer of abstraction for
easier manipulation of spatial assertions and also a clean, unified language syntax.

\paragraph{Small-Step Operational Semantics.}

We define the HNF small step semantics for both non-jumping expression ($\estep{e}{\sigma}{e'}{\sigma'}$) and
jumping expressions ($\jstep{\sigma}{e}{s: \stack}{e'}{s': \stack}$),
and then combine them together ($\cstep{e}{\sigma}{s}{e'}{\sigma'}{s'}$).

\begin{figure}
\begin{mathpar}

\infer[ES-BINOP]{\llbracket oplus \rrbracket (v_1, v_2) = v'}{\estep{v_1 \oplus v_2}{\sigma}{v'}{\sigma}}

\infer[ES-DEREF-TYPED]{\tychk{v}{\tau} \quad \sigma \vdash l \mapsto \encode(v)}{\estep{\dereft{\tau}{l}}{\sigma}{v}{\sigma}}

\infer[ES-FST]{}{\estep{\efst{(v_1, v_2)}}{\sigma}{v_1}{\sigma}}

\infer[ES-SND]{}{\estep{\esnd{(v_1, v_2)}}{\sigma}{v_2}{\sigma}}

\infer[ES-ASSIGN]{}{\estep{l \la v}{\sigma}{\sskip}{\sigma[ l \mapsto \encode(v) ]}}

\infer[ES-SEQ]{}{\estep{v ; e}{\sigma}{e}{\sigma}}

\infer[ES-ALLOC]{\tychk{v}{\tau} \quad \All o'. \sigma(b, o') = \bot}{\estep{\alloc{\tau}{v}}{\sigma}{\vaddr{b}{o}}{\sigma[\vaddr{b}{o} \mapsto v]}}

\infer[ES-WHILE-TRUE]{}{\estep{\swhile{e}{\vtrue}{s}}{\sigma}{s; \swhile{e}{e}{s}}{\sigma}}

\infer[ES-WHILE-FALSE]{}{\estep{\swhile{e}{\vfalse}{s}}{\sigma}{\sskip}{\sigma}}

\infer[ES-BIND']{\isjmp(e) = \FALSE \quad \estep{e}{\sigma}{e'}{\sigma'}}{\estep{(k::ks)e}{\sigma}{(k::ks)e'}{\sigma'}}

\end{mathpar}
\caption{Semantics rules}
\end{figure}

XXX: Define $\sigma \vdash l \mapsto \vec \bval$

\subsection{Type System and Environment}

\paragraph{Local Typing Rules.}

The types are defined in \Sref{p:type}, and all values in $\val$ can be \emph{locally} typed trivially (since $\val$ is introduced to reflect type structure in some sense). Nevertheless, due to the fact that language of study is weakly-typed in the vein of C, we still have some ``weird'' rules worth documenting.

Here we define local typing judgment $\tychk{v}{\tau}$ for values.

\begin{mathpar}
\infer[tychk-void]{}{\tychk{\void}{\tyvoid}}

\infer[tychk-null]{}{\tychk{\vnull}{\tynull}}

\infer[tychk-int8]{}{\tychk{i \in [0, 2^8)}{\tybyte}}

\infer[tychk-int32]{}{\tychk{i \in [0, 2^{32})}{\tyword}}

\infer[tychk-null-ptr]{}{\All \tau. \tychk{\vnull}{\typtr{\tau}}}

\infer[tychk-ptr]{}{\All \tau, l. \tychk{l}{\typtr{\tau}}}

\infer[tychk-prod]{\tychk{v_1}{\tau_1} \quad \tychk{v_2}{\tau_2}}{\tychk{(v_1, v_2)}{\tau_1 \times \tau_2}}

\end{mathpar}

\paragraph{Typing Environment}

When variables are introduced, we will need an environment $\Gamma : \Env \eqdef [x \gmapsto (\tau, l)]$
to ``unfold'' the meaning of variables.

In Iris-OS, variables are all unfolded before the running the function body,
which saves the program logic from caring about the lexical environment.
During this unfolding, we will replace variables with either their location (left-hand side)
or the dereference of their location (right-hand side). And we will also produce a pointer arithmetic
expression when processing the left-hand side expression, which requires type inference $\tyinf{e}{\tau}$
(since it is standard and trivial, we will leave out the details here).

Then we define the rules for ``interpreting'' left-hand side expression ($\reslhs{e}$)
and right-hand side expression ($\resrhs{e}$). In all rules below, a $\Gamma$ is implicitly
captured, and if any operation on $\Gamma$ failed, then the rule will be returning ``invalid'' in implementation.

\begin{align*}
\reslhs{e_1 \la e_2} =&\, \reslhs{e_1} \la e_2\\
\reslhs{x} =&\, \Gamma(x).l \\
\reslhs{\deref{e}} =&\, \resrhs{e} \\
\reslhs{\efst{e}} =&\, \reslhs{e} \\
\reslhs{\esnd{e}} =&\, \reslhs{e} + \sizeof(\tau) \quad \text{if } \tyinf{\reslhs{e}}{\typtr{(\tau_1 \times \tau_2)}}\\
\reslhs{l} =&\, l\\
\\
\resrhs{e_1 \la e_2} =&\, e_1 \la \resrhs{e_2}\\
\resrhs{x} =&\, \dereft{\Gamma(x).t}{\Gamma(x).l} \\
\resrhs{\deref{e}} =&\, \dereft{\tau}{\resrhs{e}} \quad \text{if } \tyinf{e}{\typtr{\tau}}
\end{align*}

The cases not covered are defined recursively (and trivially)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "iris"
%%% End:
