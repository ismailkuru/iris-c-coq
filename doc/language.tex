\section{Language}
\label{sec:language}

\subsection{Definitions}

\paragraph{Syntax.}\label{p:type}

The language is a simplified version of C. It consists of \Stmts{} (statements), \Prim{} (primitives),
\Expr{} (expressions), \Type{} (types) and \Val{} (values).

Memory address $l: \Addr \eqdef \vaddr{b}{o}$ where block address $b \in \nat$, offset $o \in \integer^{+}$.

\begin{align*}
    \tau : \Type \bnfdef{}&
        \tyvoid \mid \tynull \mid \tybyte \mid \tyword \mid \typtr{\tau} \mid \tau \times \tau
\\
    v : \Val \bnfdef{}&
        \void \mid \vnull \mid i \in [0, 2^8) \mid i \in [0, 2^{32}) \mid l \mid (v, v)
\\
    e : \Expr \bnfdef{}&
        v \mid x \mid e \oplus e \mid \deref{e} \mid \& e \mid \ecast{e}{\tau} \mid \efst{e} \mid \esnd{e}
\\
    p : \Prim \bnfdef{}&
        \pcli \mid \psti
\\
    s : \Stmts \bnfdef{}&
        \sskip \mid p \mid e \la e \mid \sif{e}{s}{s} \mid \swhile{e}{s} \mid \\&
        \sret \mid \srete{e} \mid \scall{f}{e_1, ..., e_n} \mid s ; s
\\
\end{align*}

\paragraph{Program.}

A program is considered to be a set of functions, each identified by its name. Each
function is a triple of return type $\tau_{ret}$, parameter declarations $(x_1 : \tau_1, ...)$,
and function body $s$.

\paragraph{Evaluation Context.}

To make the evaluation order explicit and reusable by the $\text{WP-BIND}$ rule, we define evaluation context.
Compared to a simple expression-based language which has only one kind of context $\ctx$, we define two contexts
$\ctx_e, \ctx_s$ for both $\Expr$ and $\Stmts$:

\begin{align*}
    \ctx_e : \ectx \eqdef{}&
        \emptyctx \mid \emptyctx \oplus e \mid v \oplus \emptyctx \mid
        \deref{\emptyctx} \mid \& \emptyctx \mid \ecast{\emptyctx}{\tau} \mid
        \efst{\emptyctx} \mid \esnd{\emptyctx}
\\
    \ctx_s : \sctx \eqdef{}&
        \emptyctx \la e \mid l \la \emptyctx \mid \sif{\emptyctx}{s}{s} \mid \swhile{\emptyctx}{s} \mid \\&
         \srete{\emptyctx} \mid \scall{f}{v_1, ..., \emptyctx, e_1, ...}
\end{align*}

Now we can define \emph{context}: $\ctx : \allctx \eqdef (\ctx_e, \ctx_s)$.

\subsection{Semantics}
\paragraph{Model.}

Define $c: \Code \eqdef (\cureval: \{ \Expr + \Stmts\}, \curctx: \allctx, \ctx^{*}: [\allctx])$, in which

\begin{itemize}
\item $\cureval$ is the ``current evaluation'', which could be either an expression $e^\dag$ or a statement $s^\dag$.
\item $\curctx$ is the ``current context'', which semantically means rest code to execute in current frame.
\item $\ctx^{*}$ is the ``previous contexts'', which semantically means previous frames on call stack
\end{itemize}

Next, we define byte-size value and memory model:

\[\bval : \byteval \eqdef \mundef \mid i \in [0, 2^8) \mid l_{\{0 \mid 1 \mid 2 \mid 3\}} \mid \vnull\]

We define state $\sigma: \State \eqdef [ b \gmapsto [\bval] ]$,
i.e. a heap in which every block maps to a list of byte-size values.

You may notice the difference between $\Val$ and $\byteval$, it is intentional to create a layer of abstraction for
easier manipulation of spatial assertions and also a clean, unified language syntax.

\paragraph{Small-Step Operational Semantics.}

TODO.

\subsection{Type System and Environment}

\paragraph{Local Typing Rules.}

The types are defined in \Sref{p:type}, and all values in $\val$ can be \emph{locally} typed trivially (since $\val$ is introduced to reflect type structure in some sense). Nevertheless, due to the fact that language of study is weakly-typed in the vein of C, we still have some ``weird'' rules worth documenting.

Here we define local typing judgement $\tychk{v}{\tau}$ for values.

\begin{mathpar}
\infer[tychk-void]{}{\tychk{\void}{\tyvoid}}

\infer[tychk-null]{}{\tychk{\vnull}{\tynull}}

\infer[tychk-int8]{}{\tychk{i \in [0, 2^8)}{\tybyte}}

\infer[tychk-int32]{}{\tychk{i \in [0, 2^{32})}{\tyword}}

\infer[tychk-int8-to-32]{\tychk{v}{\tybyte}}{\tychk{v}{\tyword}}

\infer[tychk-int32-to-8]{\tychk{i \in [0, 2^8)}{\tyword}}{\tychk{i}{\tybyte}}

\infer[tychk-null-ptr]{}{\All \tau. \tychk{\vnull}{\typtr{\tau}}}

\infer[tychk-ptr]{}{\All \tau, l. \tychk{l}{\typtr{\tau}}}

\infer[tychk-ptr-cast]{\tychk{v}{\typtr{\tau}}}{\tychk{v}{\typtr{\tau'}}}

\infer[tychk-prod]{\tychk{v_1}{\tau_1} \quad \tychk{v_2}{\tau_2}}{\tychk{(v_1, v_2)}{\tau_1 \times \tau_2}}

\end{mathpar}

\paragraph{Typing Environment}

When variables are introduced, we will need an environment $\Gamma : \Env \eqdef [x \gmapsto (\tau, l)]$
to ``unfold'' the meaning of variables.

In Iris-OS, variables are all unfolded before the running the function body,
which saves the program logic from caring about the lexical environment.
During this unfolding, we will replace variables with either their location (left-hand side)
or the dereference of their location (right-hand side). And we will also produce a pointer arithmetic
expression when processing the left-hand side expression, which requires type inference.

Here we first define the type inference rules. Although it is written in an axiomatic way,
it is a direct translation of our monadic algorithm (TODO).

Then we define the rules for ``interpreting'' left-hand side expression (TODO).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "iris"
%%% End:
