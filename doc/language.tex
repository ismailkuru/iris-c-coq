\section{Language}
\label{sec:language}

\subsection{Definitions}

\paragraph{Syntax.}\label{p:type}

The language is a simplified version of C. It mainly consists of
\Expr{} (expressions), \Type{} (types) and \Val{} (values).

\begin{align*}
    \tau : \Type \bnfdef{}&
        \tyvoid \mid
        \tynull \mid
        \tybyte \mid
        \tyword \mid
        \typtr{\tau} \mid
        \tau \times \tau
\\
    v : \Val \bnfdef{}&
        \void \mid
        \vnull \mid
        i \in [0, 2^8) \mid
        i \in [0, 2^{32}) \mid
        l \mid
        (v, v)
\\
    e : \Expr \bnfdef{}&
       v \mid
       x \mid
       e \oplus e \mid
       \ederef{e} \mid
       \edereft{\tau}{e} \mid
       \eaddrof{e} \mid
       \efst{e} \mid
       \esnd{e}
       \\&
       e \la e \mid
       \eif{e}{e}{e} \mid
       \ewhile{e}{e}{e} \mid
       \\&
       \erete{e} \mid
       \ecall{\tau}{f}{e_1, ..., e_n} \mid
       e ; e \mid
       \ealloc{\tau}{e} \mid
       \\&
       \elet{\tau}{x}{e}{e} \mid
       \eCAS{\tau}{e}{e}{e}
\\
\end{align*}

We also have following definitions:

\begin{itemize}
  \item block address $b \in \nat$
  \item offset $o \in \integer^{+}$
  \item Memory address $l: \Addr \eqdef \vaddr{b}{o}$
  \item Program $\Sigma: \Text \eqdef [f \gmapsto \Funct]$ is a list of functions indexed by names
  \item Function $F: \Funct \eqdef (\tau_{ret} \times [x_1 : \tau_1, ...] \times e)$ consists of return type,
    parameter declarations and function body.
\end{itemize}

(NOTE) The relationship between $\ederef{e}$ and $\edereft{\tau}{e}$: The former one is only used in source,
and the later one is used in the actual semantics and inference rules.
By adding a pre-processing step which instantiates all source-only expression to substituted/typed ones,
we can remove lexical and typing environment from the core program logic. The details are in \ref{par:tyev}.

(NOTE) Compared with C, there are several notable differences:
\begin{enumerate}
  \item We currently don't support declarations of local variables, \texttt{for} loop and \texttt{switch},
    \texttt{break} and \texttt{continue}
  \item C differentiates statements and expressions (so do many other program logics). For simplicity and
    expressivity, we merged them together into a coherent expression $\Expr$ instead
\end{enumerate}

\paragraph{Evaluation Context.}

To make the evaluation order explicit and reflected to the logic through the bind rule,
we define the \emph{evaluation context}:

\begin{align*}
    \ctx : \ectx \eqdef{}&
        \elet{\tau}{x}{\emptyctx}{e} \mid
        \emptyctx \oplus e \mid
        v \oplus \emptyctx \mid
        \edereft{\tau}{\emptyctx} \mid
        \eaddrof{\emptyctx} \mid
        \efst{\emptyctx} \mid
        \esnd{\emptyctx} \mid
        \\&
        \eCAS{\tau}{\emptyctx}{e}{e} \mid
        \eCAS{\tau}{l}{\emptyctx}{e} \mid
        \eCAS{\tau}{l}{v}{\emptyctx} \mid
        \\&
        \emptyctx \la e \mid
        l \la \emptyctx \mid
        \eif{\emptyctx}{e}{e} \mid
        \ewhile{e}{\emptyctx}{e} \mid
        \\&
        \erete{\emptyctx} \mid
        \ecall{\tau}{f}{v_1, ..., \emptyctx, e_1, ...} \mid
        \ealloc{\tau}{\emptyctx} \mid
        \emptyctx ; e
\end{align*}

\subsection{Semantics}\label{sec:semantics}
\paragraph{Model.}

First define
\begin{itemize}
\item Byte-size value \[\bval : \byteval \eqdef \mundef \mid i \in [0, 2^8) \mid l_{\{0 \mid 1 \mid 2 \mid 3\}} \mid \vnull\]
\item Heap $h: \Heap \eqdef [ l \gmapsto \bval ]$
\item Continuation $k: \Cont \eqdef [\ectx]$
\item Stack $s: \Stack \eqdef [\Cont]$
\item Whole state \[\sigma: \State \eqdef (\text{heap}: \Heap, \text{text}: \Text, \text{stack}: \Stack)\]
\end{itemize}

(NOTE) You may notice the difference between $\Val$ and $\byteval$, it is intended to create a layer of abstraction for
easier manipulation of spatial assertions and also for a clean, unified language syntax.

\paragraph{Small-Step Operational Semantics.}

We define the small-step semantics (see figure \ref{fig:semantics}) for both local reduction ($\estep{e}{h}{e'}{h'}$) and
non-local reductions ($\jstep{\Sigma}{e}{s: \Stack}{e'}{s': \Stack}$),
and then combine them together ($\cstep{e}{\sigma}{e'}{\sigma'}$) point-wise.

%% XXX: Define $\sigma \vdash l \mapsto \vec \bval$

\begin{figure}[!ht]
\begin{mathpar}\label{fig:semantics}

\infer[es-binop]{\llbracket oplus \rrbracket (v_1, v_2) = v'}{\estep{v_1 \oplus v_2}{h}{v'}{h}}

\infer[es-deref-typed]{\tychk{v}{\tau} \quad h \vdash l \mapsto \encode(v)}{\estep{\edereft{\tau}{l}}{h}{v}{h}}

\infer[es-fst]{}{\estep{\efst{(v_1, v_2)}}{h}{v_1}{h}}

\infer[es-snd]{}{\estep{\esnd{(v_1, v_2)}}{h}{v_2}{h}}

\infer[es-assign]{}{\estep{l \la v}{h}{\eskip}{h[ l \mapsto \encode(v) ]}}

\infer[es-seq]{}{\estep{v ; e}{h}{e}{h}}

\infer[es-alloc]{\tychk{v}{\tau} \quad \All o'. h(b, o') = \bot}{\estep{\ealloc{\tau}{v}}{h}{\vaddr{b}{o}}{h[\vaddr{b}{o} \mapsto v]}}

\infer[es-while-true]{}{\estep{\ewhile{c}{\vtrue}{s}}{h}{s; \ewhile{c}{c}{s}}{h}}

\infer[es-while-false]{}{\estep{\ewhile{c}{\vfalse}{s}}{h}{\eskip}{h}}

\infer[es-if-true]{}{\estep{\eif{\vtrue}{e_1}{e_2}}{h}{e_1}{h}}

\infer[es-if-false]{}{\estep{\eif{\vfalse}{e_1}{e_2}}{h}{e_2}{h}}

\infer[es-bind']{\isjmp(e) = \FALSE \quad \estep{e}{h}{e'}{h'}}{\estep{(k::ks)e}{h}{(k::ks)e'}{h'}}

\infer[es-cas-fail]
{\tychk{v_1}{\tau} \quad \tychk{v_2}{\tau} \quad \tychk{v}{\tau} \quad h \vdash l \mapsto \encode(v) \quad v_1 \neq v}
{\estep{\eCAS{\tau}{l}{v_1}{v_2}}{h}{\vfalse}{h}}

\infer[es-cas-suc]
{\tychk{v_1}{\tau} \quad \tychk{v_2}{\tau} \quad h \vdash l \mapsto \encode(v_1)}
{\estep{\eCAS{\tau}{l}{v_1}{v_2}}{h}{\vtrue}{h[ l \mapsto \encode(v_2) ]}}

\infer[es-let]
{}{\estep{\elet{\tau}{x}{v}{e}}{h}{e[x/v:\tau]}{h}}

\infer[js-rete]
  {\unfill(k(\erete{v})) = (k', \erete{v})}
  {\jstep{\Sigma}{k'(\erete{v})}{k::ks}{k(v)}{ks}}

\infer[js-call]
  {\Sigma(f) = \Funct(\tau, ps, e)}
  {\jstep{\Sigma}{k(\ecall{\tau}{f}{ls})}{ks}{e[ps/ls]}{k::ks}}

\end{mathpar}
\caption{Semantics rules}
\end{figure}

\subsection{Type System and Lexical Environment}

\paragraph{Local Typing Rules.}

The types are defined in \Sref{p:type}, and all values in $\val$ can be \emph{locally} typed trivially (since $\val$ is introduced to reflect type structure in some sense). Nevertheless, due to the fact that the language of study is weakly-typed in the vein of C, we still have some ``weird'' rules worth documenting.

Here we define local typing judgment $\tychk{v}{\tau}$ for values.

\begin{mathpar}
\infer[typeof-void]{}{\tychk{\void}{\tyvoid}}

\infer[typeof-null]{}{\tychk{\vnull}{\tynull}}

\infer[typeof-int8]{}{\tychk{i \in [0, 2^8)}{\tybyte}}

\infer[typeof-int32]{}{\tychk{i \in [0, 2^{32})}{\tyword}}

\infer[typeof-null-ptr]{}{\All \tau. \tychk{\vnull}{\typtr{\tau}}}

\infer[typeof-ptr]{}{\All \tau, l. \tychk{l}{\typtr{\tau}}}

\infer[typeof-prod]{\tychk{v_1}{\tau_1} \quad \tychk{v_2}{\tau_2}}{\tychk{(v_1, v_2)}{\tau_1 \times \tau_2}}

\end{mathpar}

Note that rule TYPEOF-NULL-PTR means that $\vnull$ can be of any pointer type,
and TYPEOF-PTR means that a pointer can have \emph{any} pointer type.

\paragraph{Lexical Environment}\label{par:tyev}

Formally, the lexical environment for a function body consists of two parts:
parameter bindings (free variables) and local bindings (introduced by \texttt{let}).

Every time we call a function, we will desugar the first part into the second part by recursively
binding parameters to allocated argument values (as implemented in \texttt{let\_params} and typesetted as $e[ps/ls]$).

Now we focus on what $e[x/v:\tau]$ means in the semantics of \texttt{let}-binding:
Essentially, variable $x$ is replaced with its binding $v$, and type information is tagged to the untyped parts when in need.
More specifically, we will replace variable with either its location (when in left-hand side)
or the dereference of its location (when in right-hand side). We will produce a pointer arithmetic
expression when processing the left-hand side expression, which in turn requires type inference $\tyinf{e}{\tau}$
(since it is standard and trivial, we will leave out the details here).

We won't document the algorithmic rules for rewriting expressions.
You may refer to \texttt{resolve\_rhs}, \texttt{resolve\_lhs\_outer} and \texttt{resolve\_lhs\_inner} for details.
