\section{Language}
\label{sec:language}

\subsection{Definitions}

\paragraph{Syntax.}\label{p:type}

The language is a simplified version of C. It mainly consists of
\Expr{} (expressions), \Type{} (types) and \Val{} (values).

\begin{align*}
    \tau : \Type \bnfdef{}&
        \tyvoid \mid \tynull \mid \tybyte \mid \tyword \mid \typtr{\tau} \mid \tau \times \tau
\\
    v : \Val \bnfdef{}&
        \void \mid \vnull \mid i \in [0, 2^8) \mid i \in [0, 2^{32}) \mid l \mid (v, v)
\\
    e : \Expr \bnfdef{}&
       v \mid x \mid e \oplus e \mid \deref{e} \mid \dereft{\tau}{e} \mid \& e \mid \efst{e} \mid \esnd{e} \\&
       \sskip \mid e \la e \mid \sif{e}{e}{e} \mid \swhile{e}{e}{e} \mid \\&
       \srete{e} \mid \scall{f}{e_1, ..., e_n} \mid e ; e \mid \alloc{\tau}{e}
\\
\end{align*}

We also have following definitions:

\begin{itemize}
  \item block address $b \in \nat$
  \item offset $o \in \integer^{+}$
  \item Memory address $l: \Addr \eqdef \vaddr{b}{o}$
  \item Program $\Sigma: \Text \eqdef [f \gmapsto \Funct]$ is a list of functions indexed by names
  \item Function $F: \Funct \eqdef (\tau_{ret} \times [x_1 : \tau_1, ...] \times e)$ consists of return type,
    parameter declarations and function body.
\end{itemize}

(NOTE) The relationship between $\deref{e}$ and $\dereft{\tau}{e}$: The former one is only used in source,
and the later one is used in the actual semantics and inference rules.
By adding a pre-processing step which instantiates all source-only expression to substituted/typed ones,
we can remove lexical and typing environment from the core program logic. The details are in \ref{par:tyev}.

(NOTE) Compared with C, there are several notable differences:
\begin{enumerate}
  \item We currently don't support declarations of local variables, \texttt{for} loop and \texttt{switch},
    \texttt{break} and \texttt{continue}
  \item C differentiates statements and expressions (so do many other program logics). For simplicity and
    expressivity, we merged them together into a coherent expression $\Expr$ instead
\end{enumerate}

\paragraph{Evaluation Context.}

To make the evaluation order explicit and reflected to the logic through the bind rule,
we define the \emph{evaluation context}:

\begin{align*}
    \ctx : \ectx \eqdef{}&
        \emptyctx \oplus e \mid v \oplus \emptyctx \mid
        \deref{\emptyctx} \mid \& \emptyctx \mid
        \efst{\emptyctx} \mid \esnd{\emptyctx} \mid \\&
        \emptyctx \la e \mid l \la \emptyctx \mid \sif{\emptyctx}{e}{e} \mid \swhile{e}{\emptyctx}{e} \mid \\&
        \srete{\emptyctx} \mid \scall{f}{v_1, ..., \emptyctx, e_1, ...} \mid \alloc{\tau}{\emptyctx} \mid \emptyctx ; e
\end{align*}

\subsection{Semantics}\label{sec:semantics}
\paragraph{Model.}

First define
\begin{itemize}
\item Byte-size value \[\bval : \byteval \eqdef \mundef \mid i \in [0, 2^8) \mid l_{\{0 \mid 1 \mid 2 \mid 3\}} \mid \vnull\]
\item Heap $h: \Heap \eqdef [ l \gmapsto \bval ]$
\item Continuation $k: \Cont \eqdef [\ectx]$
\item Stack $s: \Stack \eqdef [\Cont]$
\item Whole state \[\sigma: \State \eqdef (\text{heap}: \Heap, \text{text}: \Text, \text{stack}: \Stack)\]
\end{itemize}

(NOTE) You may notice the difference between $\Val$ and $\byteval$, it is intended to create a layer of abstraction for
easier manipulation of spatial assertions and also for a clean, unified language syntax.

\paragraph{Small-Step Operational Semantics.}

We define the small-step semantics (see figure \ref{fig:semantics}) for both local reduction ($\estep{e}{h}{e'}{h'}$) and
non-local reductions ($\jstep{\Sigma}{e}{s: \Stack}{e'}{s': \Stack}$),
and then combine them together ($\cstep{e}{\sigma}{e'}{\sigma'}$) point-wise.

%% XXX: Define $\sigma \vdash l \mapsto \vec \bval$

\begin{figure}[!ht]
\begin{mathpar}\label{fig:semantics}

\infer[ES-BINOP]{\llbracket oplus \rrbracket (v_1, v_2) = v'}{\estep{v_1 \oplus v_2}{h}{v'}{h}}

\infer[ES-DEREF-TYPED]{\tychk{v}{\tau} \quad h \vdash l \mapsto \encode(v)}{\estep{\dereft{\tau}{l}}{h}{v}{h}}

\infer[ES-FST]{}{\estep{\efst{(v_1, v_2)}}{h}{v_1}{h}}

\infer[ES-SND]{}{\estep{\esnd{(v_1, v_2)}}{h}{v_2}{h}}

\infer[ES-ASSIGN]{}{\estep{l \la v}{h}{\sskip}{h[ l \mapsto \encode(v) ]}}

\infer[ES-SEQ]{}{\estep{v ; e}{h}{e}{h}}

\infer[ES-ALLOC]{\tychk{v}{\tau} \quad \All o'. h(b, o') = \bot}{\estep{\alloc{\tau}{v}}{h}{\vaddr{b}{o}}{h[\vaddr{b}{o} \mapsto v]}}

\infer[ES-WHILE-TRUE]{}{\estep{\swhile{c}{\vtrue}{s}}{h}{s; \swhile{c}{c}{s}}{h}}

\infer[ES-WHILE-FALSE]{}{\estep{\swhile{c}{\vfalse}{s}}{h}{\sskip}{h}}

\infer[ES-BIND']{\isjmp(e) = \FALSE \quad \estep{e}{h}{e'}{h'}}{\estep{(k::ks)e}{h}{(k::ks)e'}{h'}}

\infer[JS-RETE]
  {\unfill(k(\srete{v})) = (k', \srete{v})}
  {\jstep{\Sigma}{k'(\srete{v})}{k::ks}{k(v)}{ks}}

\infer[JS-CALL]
  {\Sigma(f) = \Funct(\any, ps, e)}
  {\jstep{\Sigma}{k(\scall{f}{ls})}{ks}{e[ps/ls]}{k::ks}}

\end{mathpar}
\caption{Semantics rules}
\end{figure}

\subsection{Type System and Lexical Environment}

\paragraph{Local Typing Rules.}

The types are defined in \Sref{p:type}, and all values in $\val$ can be \emph{locally} typed trivially (since $\val$ is introduced to reflect type structure in some sense). Nevertheless, due to the fact that language of study is weakly-typed in the vein of C, we still have some ``weird'' rules worth documenting.

Here we define local typing judgment $\tychk{v}{\tau}$ for values.

\begin{mathpar}
\infer[typeof-void]{}{\tychk{\void}{\tyvoid}}

\infer[typeof-null]{}{\tychk{\vnull}{\tynull}}

\infer[typeof-int8]{}{\tychk{i \in [0, 2^8)}{\tybyte}}

\infer[typeof-int32]{}{\tychk{i \in [0, 2^{32})}{\tyword}}

\infer[typeof-null-ptr]{}{\All \tau. \tychk{\vnull}{\typtr{\tau}}}

\infer[typeof-ptr]{}{\All \tau, l. \tychk{l}{\typtr{\tau}}}

\infer[typeof-prod]{\tychk{v_1}{\tau_1} \quad \tychk{v_2}{\tau_2}}{\tychk{(v_1, v_2)}{\tau_1 \times \tau_2}}

\end{mathpar}

Note that rule TYPEOF-NULL-PTR means that $\vnull$ can be of any pointer type,
and TYPEOF-PTR means that a pointer can have \emph{any} pointer type.

\paragraph{Lexical Environment}\label{par:tyev}

In \irisc{}, before we do any real work over a function body,
variables are all replaced with their bindings, and type information is tagged to the untyped parts when in need.
More specifically, we will replace variables with either their location (when in left-hand side)
or the dereference of their location (when in right-hand side). We will produce a pointer arithmetic
expression when processing the left-hand side expression, which in turn requires type inference $\tyinf{e}{\tau}$
(since it is standard and trivial, we will leave out the details here).

Now we write down the algorithmic rules  for rewriting left-hand side expression ($\reslhs{e}$)
and right-hand side expression ($\resrhs{e}$). Essentially, $\reslhs{e}$ will rewrite the left-hand side $e$ into its location
in memory, while $\resrhs{e}$ will add dereference to all variables in $e$.

Note that environment $\Gamma : \Env \eqdef [x \gmapsto (\tau, l)]$ is assumed, and if any operation fails, like missing something in $\Gamma$,
then the rule will indicate it in the actual implementation.
And also, the cases not covered are defined trivially.

\begin{align*}\label{envrules}
\reslhs{e_1 \la e_2} =&\, \reslhs{e_1} \la e_2\\
\reslhs{x} =&\, \Gamma(x).l \\
\reslhs{\deref{e}} =&\, \resrhs{e} \\
\reslhs{\efst{e}} =&\, \reslhs{e} \\
\reslhs{\esnd{e}} =&\, \reslhs{e} + \sizeof(\tau_1) \quad \text{if } \tyinf{\reslhs{e}}{\typtr{(\tau_1 \times \tau_2)}}\\
\reslhs{l} =&\, l\\
\\
\resrhs{e_1 \la e_2} =&\, e_1 \la \resrhs{e_2}\\
\resrhs{x} =&\, \dereft{\Gamma(x).t}{\Gamma(x).l} \\
\resrhs{\deref{e}} =&\, \dereft{\tau}{\resrhs{e}} \quad \text{if } \tyinf{e}{\typtr{\tau}}
\end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "iris"
%%% End:
