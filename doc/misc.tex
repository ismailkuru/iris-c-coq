\section{Misc}
\label{sec:misc}

This section contained some key formal developments claimed but not yet mechanized in Coq for reference.

\subsection{Basic Properties of Evaluation Context}

Our expression $\Expr$ is a recursively defined algebraic data type, which can be generalized into the following form:

\[
e : \Expr \bnfdef{} \Expr_1(A_1, e^{r_1}) \mid ... \mid \Expr_n(A_n, e^{r_n}) \mid v
\]

Here, $\Expr_i$ is tag for $i$-th class of expression, $A_i$ is its arbitrary non-recursive payload, and $e^{r_i}$ means
it has $r_i \in \nat$ recursive occurrences.

It is apparent that $\ectx$ is a direct translation of $\Expr$ plus some ordering considerations, though in actual Coq development we don't mechanize this fact.
But we will make it explicit here to support some stronger claims than what we can do in Coq.

For some abstract $\Expr$ like above, its $\ectx$ should be a sum of sub-$\ectx_i$ for each $\Expr_i$. When $r_i = 0$, $\ectx_i$ doesn't exist, now we consider
$r_i > 0$, define

\[
k_i: \ectx_i \bnfdef{} \ectx_{i1}(A_i, e^{r_i - 1}) \mid \ectx_{i2}(A_i, v^1, e^{r_i - 2}) \mid ... \mid \ectx_{ir_i}(A_i, v^{r_i - 1})
\]

\begin{theorem}
For any $e, e': \Expr$ and $k_{im}, k_{jn}: \ectx$,
\[k_{im}(e) = k_{jn}(e') \proves i = j \]
\end{theorem}
\begin{proof} Trivial. \end{proof}

\begin{theorem}
For any $e, e': \Expr$ and $k_{im}, k_{in}: \ectx_i$,
\[k_{im}(e) = k_{in}(e') \proves
 (m = n \land e = e') \lor
 (m \neq n \land (\Exists v. \toval(e) = v \lor \Exists v. \toval(e) = v))\]
\end{theorem}
\begin{proof} 

When $m = n$, by injectivity;
When $m \neq n$, we can expand the equation like below without loss of generality:
\begin{align*}
\Expr_i(A_i, v_1, ..., v_{m - 1}, &e, e_{m + 1}, ..., e_{r_i - 1}) = \\
\Expr_i(A_i', v_1', ..., v_{m - 1}', &v_m', ..., e', ...)
\end{align*}
So $e = v_m'$ by injectivity.
\end{proof}

As you may observe, the expression space spanned by $k(e)$ for any $k, e$ is not the entire
expression space as an ADT. Instead, it is a subset of $\Expr$ which represents well-formed ones
that can appear as an immediate form according to some well-defined evaluation order. We call
such $e$ is \emph{well-formed}.

\subsection{Axioms about Evaluation Context based Semantics}

In the following lemmas, we assume all involved $e$ to be \emph{well-formed}.

\begin{lemma}
$\All e: \Expr, k: \Cont . \isenf(e) \ra \unfill(k(e)) = (k, e)$
\end{lemma}
\begin{proof}

Let's prove inductively w.r.t $k$. When $k$ is empty,
since $e$ is in normal form, so unfill it will only return the same thing.
And inductively, since fill and unfill should cancel out, the final conclusion is proved trivially as well.

\end{proof}

\begin{lemma}
  $\All e, e_h, k. \unfill(e) = (k, e_h) \ra \isenf(e_h) \land e = k(e_h)$
\end{lemma}
\begin{proof}
    First, $e$ can't be a value, so we just need to consider $e$ in each legal case, which basically
    mean that either $e$ is normal form itself, or $e = K(e')$ and $\Exists k', k = K::k' \land \unfill(e') = (k', e_h)$.
    \begin{enumerate}
        \item In the first case, $k$ is forced to be $\emptyset$ and $e_h = e$, so this case is proved
        \item In the second case, we can inductively know that $e_h$ is normal form and $e' = k'(e_h)$,
              so $e = K(k'(e_h)) = (K::k')(e_h) = k(e_h)$, so this case is proved as well
    \end{enumerate}
\end{proof}


\begin{lemma}
Induction scheme I for $\Expr$:
\begin{align*}
\All P: \Expr \ra \Prop.
  &(\All e. \isenf(e) \ra P(e)) \ra \\
  &(\All e, k: \Cont . \toval(e) = \bot \ra P(e) \ra P(k(e))) \ra\\
  &(\All e. \toval(e) = \bot \ra P(e))
\end{align*}
\end{lemma}
\begin{proof}
We want to \emph{inductively} prove that for any non-value, \emph{well-formed} $e$, $P(e)$ holds.
Note that $P$ here can be any proposition.

The base case is when $e$ is in normal form, which corresponds to the first condition;
The inductive case is that for any well-formed $e'$ that is not in normal form,
it must be of the form $k(e)$ for some $k, e$. With each proved given sufficient inductive
assumption, we know that any well-formed $e$ must satisfy $P$.
\end{proof}

\begin{lemma}
  Induction scheme for $\Cont$:
  \begin{align*}
    \All P: \Cont \ra \Prop.
      &(P(\emptyset)) \ra \\
      &(\All k. (\All. k', |k'| < |k| \ra P(k')) \ra P(k)) \ra \\
      &(\All k. P(k))
  \end{align*}
\end{lemma}
\begin{proof}
    Intuitively, this is about property of natural number as the length of $k$.
    When we know $P(\emptyset)$, we know $\All K_1. P(K_1::[])$, then we know
    $\All K_2. \All K_1. P(K_2::K_1::[])$ .... Until for arbitrarily big, finite $n$,
    $\All K_n, K_{n - 1}, ..., K_1. P(K_n::K_{n-1}::...::K_1::[])$, or for any finite
    $k$, $P(k)$ holds.
\end{proof}

\begin{lemma}
Induction scheme II for $\Expr$:
\begin{align*}
\All P: \Expr \ra \Prop.
  &(\All e. \isenf(e) \ra P(e)) \ra \\
  &(\All e, k: \Cont . \isenf(e) \ra (\All k'. |k'| < |k| \ra P (k'(e))) \ra P(k(e))) \ra\\
  &(\All e. \toval(e) = \bot \ra P(e))
\end{align*}
\end{lemma}
\begin{proof}
    First, the $e$ in the final goal is implicitly well-formed, which means that $e = K(e_h)$
    for some $K, e_h$. So we prove inductively on the length of such $K$, in a similar way to
    the last lemma, and reach our final conclusion.
\end{proof}

\begin{lemma}
  Partial injectivity of fill:
  \[
  \infer{
    \toval(e) = \bot \quad
    \isenf(e_h) \quad
    k(e) = k'(e_h)}
  {\Exists k''. k' = k \append k'' \and e = k''(e_h)}
  \]
\end{lemma}
  \begin{proof}
  \begin{enumerate}
    Since $e$ is well-formed and not a value, so it can be unfilled such that $e = k''(e_h')$,
    then by \texttt{cont\_inj}, $e_h = e_h'$ and $k' = k \append k''$, which proves our claim
  \end{enumerate}
\end{proof}

\begin{lemma}
  Local step has a focus:
  \[
  \infer{\estep{e_1}{h_1}{e_2}{h_2}}
  {\Exists e_1', e_2', k. \isenf(e_1') \land e_1 = k(e_1') \land e_2 = k(e_2') \land \estep{e_1'}{h_1}{e_2'}{h_2}}
  \]
\end{lemma}
\begin{proof}
    By inversing the assumption, we know there are two possibilities:
    \begin{enumerate}
    \item If $e_1$ is already in normal form, then we just need to let $e_1' = e_1, e_2' = e_2$, and $k = \emptyset$.
    \item We know that there are some $k'', e_1'', e_2''$, where $|k''| > 0$, such that $e_1 = k''(e_1''), e_2 = k''(e_2'')$,
          and $\estep{e_1''}{h_1}{e_2''}{h_2}$. Since by the metric of depth $||_d$, $|e_1''|_d < |e_1|_d$,
          so we can derive inductively that there exists $e_1', e_2', k'$ that
          \[\isenf(e_1') \land e_1'' = k'(e_1') \land e_2'' = k'(e_2') \land \estep{e_1'}{h_1}{e_2'}{h_2}\]
          Now let $k = k '' \append k'$, and use the same $e_1', e_2'$, we can prove the original existential goal.
    \end{enumerate}
\end{proof}

\subsection{Other Facts}

\begin{lemma}
$\textlog{wp}^{+}$ is contractive.
\end{lemma}
\begin{proof}
  Observe in the definition \ref{def:wpr} that there are only two recursive uses of $\textlog{wp}^{+}$:
  \begin{enumerate}
    \item In the second branch of non-value case, we use $\textlog{wp}^{+}$ under $\pred$ of $\wpre{e_h}[\mask]{\pred}$,
    which means that, 
    \[\wpre{e_h}[\mask]{ ... \textlog{wp}^{+} ... } \nequiv{n} \wpre{e_h}[\mask]{ ... \textlog{wp}'^{+} ... } \]
    will hold if \( \textlog{wp}^{+} \nequiv{n + 1} \textlog{wp}'^{+} \), which is satisfied by assumption.
    \item In the third branch of non-value case, we use $\textlog{wp}^{+}$ under a $\later$, which is trivial to prove
    by \texttt{f\_contractive}.
  \end{enumerate}
\end{proof}

\subsection{Admitted Facts}

There are still one or more loopholes that exist behind the documented formalization.
But note that all of them are apparently true \emph{and} harmless to leave unproven for now.

\begin{itemize}
\item In \texttt{lang.v}, lemma \texttt{same\_type\_encode\_inj}'s fourth case about \texttt{int32} is admitted.
  Essential, this says something about encoding \texttt{int32} value with four bytes.
  We don't prove it now because there are not enough lemmas provided by machine integer library \texttt{Integers.v}.
\end{itemize}
