\section{Misc}
\label{sec:misc}

This section contained some key formal developments claimed but not yet mechanized in Coq for reference.

\subsection{Basic Properties of Evaluation Context}

Our expression $\Expr$ is a recursively defined algebraic data type, which can be generalized into the following form:

\[
e : \Expr \bnfdef{} \Expr_1(A_1, e^{r_1}) \mid ... \mid \Expr_n(A_n, e^{r_n}) \mid v
\]

Here, $\Expr_i$ is tag for $i$-th class of expression, $A_i$ is its arbitrary non-recursive payload, and $e^{r_i}$ means
it has $r_i \in \nat$ recursive occurrences.

It is apparent that $\ectx$ is a direct translation of $\Expr$ plus some ordering considerations, though in actual Coq development we don't mechanize this fact.
But we will make it explicit here to support some stronger claims than what we can do in Coq.

For some abstract $\Expr$ like above, its $\ectx$ should be a sum of sub-$\ectx_i$ for each $\Expr_i$. When $r_i = 0$, $\ectx_i$ doesn't exist, now we consider
$r_i > 0$, define

\[
k_i: \ectx_i \bnfdef{} \ectx_{i1}(A_i, e^{r_i - 1}) \mid \ectx_{i2}(A_i, v^1, e^{r_i - 2}) \mid ... \mid \ectx_{ir_i}(A_i, v^{r_i - 1})
\]

\begin{theorem}
For any $e, e': \Expr$ and $k_{im}, k_{jn}: \ectx$,
\[k_{im}(e) = k_{jn}(e') \proves i = j \]
\end{theorem}
\begin{proof} Trivial. \end{proof}

\begin{theorem}
For any $e, e': \Expr$ and $k_{im}, k_{in}: \ectx_i$,
\[k_{im}(e) = k_{in}(e') \proves
 (m = n \land e = e') \lor
 (m \neq n \land (\Exists v. \toval(e) = v \lor \Exists v. \toval(e) = v))\]
\end{theorem}
\begin{proof} 

When $m = n$, by injectivity;
When $m \neq n$, we can expand the equation like below without loss of generality:
\begin{align*}
\Expr_i(A_i, v_1, ..., v_{m - 1}, &e, e_{m + 1}, ..., e_{r_i - 1}) = \\
\Expr_i(A_i', v_1', ..., v_{m - 1}', &v_m', ..., e', ...)
\end{align*}
So $e = v_m'$ by injectivity.
\end{proof}

As you may observe, the expression space spanned by $k(e)$ for any $k, e$ is not the entire
expression space as an ADT. Instead, it is a subset of $\Expr$ which represents well-formed ones
that can appear as an immediate form according to some well-defined evaluation order. We call
such $e$ is \emph{well-formed}.

\subsection{Axioms about Evaluation Context based Semantics}

\begin{lemma}[estep is well-formed]
\[
\All e, \sigma, e', \sigma', \Gamma, es.
  \estep{\Gamma}{e}{\sigma}{e'}{\sigma'}{es} \Ra \textdom{wellformed}(e)
\]
\end{lemma}
\begin{proof}
TODO
\end{proof}

\begin{lemma}[cstep is well-formed]
\[
\All e, s, \sigma, e', s', \sigma', \Gamma, es.
  \cstepf{e}{s, \sigma}{e'}{s', \sigma'}{es} \Ra \textdom{wellformed}(e)
\]
\end{lemma}
\begin{proof}
TODO
\end{proof}

\subsection{Other Facts}

\begin{lemma}
$\textlog{wp}^{+}$ is contractive.
\end{lemma}
\begin{proof}
  Observe in the definition \ref{def:wpr} that there are only two recursive uses of $\textlog{wp}^{+}$:
  \begin{enumerate}
    \item In the second branch of non-value case, we use $\textlog{wp}^{+}$ under $\pred$ of $\wpre{e_h}[\mask]{\pred}$,
    which means that, 
    \[\wpre{e_h}[\mask]{ ... \textlog{wp}^{+} ... } \nequiv{n} \wpre{e_h}[\mask]{ ... \textlog{wp}'^{+} ... } \]
    will hold if \( \textlog{wp}^{+} \nequiv{n + 1} \textlog{wp}'^{+} \), which is satisfied by assumption.
    \item In the third branch of non-value case, we use $\textlog{wp}^{+}$ under a $\later$, which is trivial to prove
    by \texttt{f\_contractive}.
  \end{enumerate}
\end{proof}

\subsection{Admitted Facts}

There are still one or more loopholes that exist behind the documented formalization.
But note that all of them are apparently true \emph{and} harmless to leave unproven for now.

\begin{itemize}
\item In \texttt{lang.v}, lemma \texttt{same\_type\_encode\_inj}'s fourth case about \texttt{int32} is admitted.
  Essential, this says something about encoding \texttt{int32} value with four bytes.
  We don't prove it now because there are not enough lemmas provided by machine integer library \texttt{Integers.v}.
\item In \texttt{lang.v}, lemma \texttt{instantiate\_let\_preserves\_not\_jmp} states a trivial truth about a complex
  computational process.
\end{itemize}
