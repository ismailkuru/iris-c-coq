\section{Program Logic}
\label{sec:program-logic}

This section describes how to build a program logic for the C language (\cf \Sref{sec:language}) on top of the base logic of Iris.

\subsection{Extended Assertions}

Using the standard Iris assertions and the ownership of ghost heap resource, we can define some basic custom assertions:

\begin{align*}
l \mapsto_q v : t \eqdef{}&  l \mapsto_q \encode(v) \land \tychk{v}{t} \\
l \mapsto v : t              \eqdef{}& l \mapsto_1 v : t\\
l \mapsto_q - : t            \eqdef{}& \Exists v. l \mapsto_q v : t
\end{align*}

\subsection{Weakest Precondition}

Finally, we can define the core piece of the program logic, the assertion that reasons about program behavior: Weakest precondition, from which Hoare triples will be derived.

\paragraph{Defining weakest precondition.}

While we have fixed the program state $\sigma$ in language definition, but it can be any state, as long as it has a predicate
$S : \State \to \iProp$ that interprets the physical state as an Iris assertion.
For our heap state, $S(\sigma) \eqdef \ownPhys{\authfull \fmap (\lambda v. (1, \aginj v), \sigma)}$.

\begin{align*}
  \textdom{wp} \eqdef{}& \MU \textdom{wp}. \Lam \mask, \cureval, \pred, \predret. \\
        & (\Exists v. \toval(\cureval) = v \land \pvs[\mask] \pred(v)) \lor {}\\
        & (\Exists v. \toretval(\cureval) = v \land \pvs[\mask] \predret (v)) \lor {}\\
        & \Bigl(\toval(\cureval) = \bot \land \toretval(\cureval) = \bot \land \\
        &\qquad \All \state. S(\state) \vsW[\mask][\emptyset] {}\\
        &\qquad \red(e, \state) * \later\All \cureval', \state'. (\cureval, \state \step \cureval', \state') \vsW[\emptyset][\mask] {}\\
        &\qquad\qquad S(\state') * \textdom{wp}(\mask, \cureval', \pred, \predret)\Bigr) \\
\end{align*}

Here are some conventions:

\begin{itemize}
\item If we leave away the mask, we assume it to default to $\top$.
\item We will leave $\dag$ out when writing $\cureval$ in WP.
\item $\pred$ in post-condition might or might not take a value parameter, depending on the context.
\end{itemize}

\paragraph{Laws of weakest precondition.}
The following rules can all be derived:
\begin{mathpar}
\infer[wp-value]
{}{\pred(\val) \proves \wpre{\val}[\mask]{\pred}{\predret}}

\infer[wp-skip]
{}{\pred(\void) \proves \wpre{\val}[\mask]{\pred}{\predret}}

\infer[wp-ret]
{}{\predret(v) \proves \wpre{\srete{v}}[\mask]{\pred}{\predret}}


\infer[wp-strong-mono]
{\mask_1 \subseteq \mask_2}
{((\All v. \Phi(v) \pvs[\mask_2] \Psi(v)) \land (\All v. \predret(v) \pvs[\mask_2] \Psi_\text{ret}(v))) * \wpre\cureval[\mask_1]{\pred}{\predret}
 \proves \wpre\cureval[\mask_2]{\Psi}{\Psi_\text{ret}}}

\infer[fup-wp]
{}{\pvs[\mask] \wpre\cureval[\mask]{\pred}{\predret} \proves \wpre\cureval[\mask]{\pred}{\predret}}

\infer[wp-fup]
{}{\wpre\cureval[\mask]{\Ret\var.\pvs[\mask] \pred(\var)}{\Ret\var.\pvs[\mask] \predret(\var)} \proves \wpre\expr[\mask]{\pred}{\predret}}

% \infer[wp-atomic]
% {\physatomic{\expr}}
% {\pvs[\mask_1][\mask_2] \wpre\expr[\mask_2]{\Ret\var. \pvs[\mask_2][\mask_1]\prop}
%  \proves \wpre\expr[\mask_1]{\Ret\var.\prop}}

% \infer[wp-frame]
% {}{\propB * \wpre\expr[\mask]{\Ret\var.\prop} \proves \wpre\expr[\mask]{\Ret\var.\propB*\prop}}

% \infer[wp-frame-step]
% {\toval(\expr) = \bot \and \mask_2 \subseteq \mask_1}
% {\wpre\expr[\mask_2]{\Ret\var.\prop} * \pvs[\mask_1][\mask_2]\later\pvs[\mask_2][\mask_1]\propB \proves \wpre\expr[\mask_1]{\Ret\var.\propB*\prop}}

\infer[wp-bind]
{}
{\wpre\expr[\mask]{\Ret\var. \wpre{\ctx(\var)}[\mask]{\pred}{\predret}}{\predret}
 \proves 
 \wpre{\ctx(\expr)}[\mask]{\pred}{\predret}}

 \infer[wp-op]
{\llbracket oplus \rrbracket (v_1, v_2) = v'}
{\pred(v')
 \proves
 \wpre{v_1 \oplus v_2}[\mask]{\pred}{\predret}}

 \infer[wp-assign]
{\tychk{v}{\tau'} \quad \assigncomp{\tau}{\tau'}}
{ l \mapsto - : \tau * (l \mapsto v : \tau \wand \pred)
 \proves
 \wpre{l \la v}[\mask]{\pred}{\predret}}

 \infer[wp-assign-offset]
{\tychk{v_2}{\tau_2'} \quad \assigncomp{\tau_2}{\tau_2'}}
{ \vaddr{b}{o} \mapsto (v_1, -) : \tau_1 \times \tau_2 *
  (\vaddr{b}{o} \mapsto (v_1, v_2) : \tau_1 \times \tau_2 \wand \pred)
 \proves
 \wpre{\vaddr{b}{(o + \sizeof(\tau_1))} \la v_2}[\mask]{\pred}{\predret}}


 \infer[wp-load]
{}
{ l \mapsto_q v : \tau  * (l \mapsto_q v : \tau \wand \pred (v))
 \proves
 \wpre{\dereft{\tau}{l}}[\mask]{\pred}{\predret}}

\infer[wp-seq]
{}
{\wpre{s_1}[\mask]{\wpre{s_2}[\mask]{\pred}{\predret}}{\predret} 
 \proves
 \wpre{s_1 ; s_2}[\mask]{\pred}{\predret}}

\infer[wp-while-true]
{\wpre{s; \swhile{e}{e}{s}}[\mask]{\pred}{\predret}}
{\wpre{\swhile{e}{\vtrue}{s}}[\mask]{\pred}{\predret}}

\infer[wp-while-false]
{\pred(\void)}
{\wpre{\swhile{e}{\vfalse}{s}}[\mask]{\pred}{\predret}}

\infer[wp-while-inv]
{\begin{inbox}
 \All \pred. (I * (\All v. (v = \vfalse * Q(\void)) \vee (v = \vtrue * I)) \wand \pred(v)) \wand \wpre{e}{\pred}{\TRUE} \\
 \qquad\qquad\qquad\qquad \All \pred. (I * (I \wand \pred(\void))) \wand \wpre{s}{\pred}{\predret}
 \end{inbox}}
{I \proves \wpre{\swhile{e}{e}{s}}{Q}{\predret}}

\end{mathpar}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "iris"
%%% End:
