\section{Program Logic}
\label{sec:program-logic}

This section describes how to build a program logic for the C language (\cf \Sref{sec:language}) on top of Iris..

\subsection{Extended Assertions}

Using the standard Iris assertions and the ownership of ghost heap resource, we can define some basic custom assertions:

\begin{align*}
l \mapsto_q v : t \eqdef{}&  l \mapsto_q \encode(v) \land \tychk{v}{t} \\
l \mapsto v : t              \eqdef{}& l \mapsto_1 v : t\\
l \mapsto_q - : t            \eqdef{}& \Exists v. l \mapsto_q v : t\\
\ownstack(s) \eqdef{}& \ownGhost{\Stack}{(\frac12, \aginj s)} \\
f \tmapsto F \eqdef{}& \ownGhost{\Text}{\authfrag \mapsingleton{f}{\aginj F}}
\end{align*}

\subsection{Weakest Precondition}

\paragraph{Defining weakest precondition.}

The state interpreting predicate $S : \State \to \iProp$ for our \irisc{} language is defined below, as required for
instantiating the parametric WP provided by Iris already (but we copy its definition over for reference).

\[S(\sigma) \eqdef 
  \ownGhost{\Heap}{\authfull \fmap (\lambda v. (1, \aginj v), \sigma.\text{heap})} *
  \ownGhost{\Text}{\authfull \fmap (\aginj, \sigma.\text{text})} *
  \ownGhost{\Stack}{(\frac12, \sigma.\text{stack})}
\]

\begin{align*}
  \textdom{wp} \eqdef{}& \MU \textdom{wp}. \Lam \mask, e, \pred. \\
        & (\Exists v. \toval(e) = v \land \pvs[\mask] \pred(v)) \lor {}\\
        & \Bigl(\toval(e) = \bot \,\land \\
        &\qquad \All \state. S(\state) \vsW[\mask][\emptyset] {}\\
        &\qquad \red(e, \state) * \later\All e', \state'. \cstep{e}{\state}{e'}{\state'} \vsW[\emptyset][\mask] {}\\
        &\qquad\qquad S(\state') * \textdom{wp}(\mask, e', \pred)\Bigr) \\
\end{align*}

Here are some conventions:

\begin{itemize}
\item If we leave away the mask $\mask$, we assume it to be $\top$.
\item $\pred$ in post-condition might or might not take a value parameter, depending on the context.
\end{itemize}

\paragraph{Laws of weakest precondition.}
The rules in figure \ref{fig:wp-general} and figure \ref{fig:wp-irisc} can all be derived.

\begin{figure}[!ht]
\label{fig:wp-general}
\begin{mathpar}
\infer[wp-value]
{}{\pred(\val) \proves \wpre{\val}[\mask]{\pred}}


\infer[wp-atomic]
{\physatomic{\expr}}
{\pvs[\mask_1][\mask_2] \wpre\expr[\mask_2]{\Ret\var. \pvs[\mask_2][\mask_1]\prop}
 \proves \wpre\expr[\mask_1]{\Ret\var.\prop}}

\infer[wp-strong-mono]
{\mask_1 \subseteq \mask_2}
{((\All v. \Phi(v) \pvs[\mask_2] \Psi(v)) \land (\All v. \predret(v) \pvs[\mask_2] \Psi_\text{ret}(v))) * \wpre\cureval[\mask_1]{\pred}
 \proves \wpre\cureval[\mask_2]{\Psi}{\Psi_\text{ret}}}

\infer[fup-wp]
{}{\pvs[\mask] \wpre\cureval[\mask]{\pred} \proves \wpre\cureval[\mask]{\pred}}

\infer[wp-fup]
{}{\wpre\cureval[\mask]{\Ret\var.\pvs[\mask] \pred(\var)}{\Ret\var.\pvs[\mask] \predret(\var)} \proves \wpre\expr[\mask]{\pred}}

\end{mathpar}
\caption{General WP rules provided by Iris}
\end{figure}

\begin{figure}[!ht]
\label{fig:wp-irisc}
\begin{mathpar}

\infer[wp-skip]
{}{\later \wpre{e}[\mask]{\pred} \proves \wpre{\val; e}[\mask]{\pred}}

 \infer[wp-assign]
{\tychk{v}{\tau'} \quad \assigncomp{\tau}{\tau'}}
{ \later l \mapsto - : \tau * \later (l \mapsto v : \tau \wand \pred)
 \proves
 \wpre{l \la v}[\mask]{\pred}}

\infer[wp-ret]
{}{\ownstack(k'::ks) * (\ownstack(ks) \wand \wpre{k'(v)}[\mask]{\pred}) \proves \wpre{k(\erete{v})}[\mask]{\pred}}

\infer[wp-bind]
{\isjmp(e) = \FALSE}
{\wpre\expr[\mask]{\Ret\var. \wpre{k(\var)}[\mask]{\pred}}
 \proves 
 \wpre{k(\expr)}[\mask]{\pred}}

 \infer[wp-op]
{\llbracket oplus \rrbracket (v_1, v_2) = v'}
{\pred(v')
 \proves
 \wpre{v_1 \oplus v_2}[\mask]{\pred}}

 \infer[wp-load]
{}
{ \later l \mapsto_q v : \tau  * \later (l \mapsto_q v : \tau \wand \pred (v))
 \proves
 \wpre{\edereft{\tau}{l}}[\mask]{\pred}}

\infer[wp-seq]
{\isjmp(e_1) = \FALSE}
{\wpre{e_1}[\mask]{v,\,\wpre{v;e_2}[\mask]{\pred}}
 \proves
 \wpre{e_1 ; e_2}[\mask]{\pred}}

\infer[wp-while-true]
{}{\later \wpre{s; \ewhile{c}{c}{s}}[\mask]{\pred}
   \proves \wpre{\ewhile{c}{\vtrue}{s}}[\mask]{\pred}}

\infer[wp-while-false]
{}{\later \pred(\void)
   \proves \wpre{\ewhile{c}{\vfalse}{s}}[\mask]{\pred}}

\infer[wp-while-inv]
{ {\begin{inbox}
      \qquad\qquad\qquad \isjmp(s) = \FALSE \qquad \isjmp(c) = \FALSE \\ \All \pred. (I * (\All v. (v = \vfalse * Q(\void)) \vee (v = \vtrue * I)) \wand \pred(v)) \wand \wpre{c}{\pred} \\ \qquad\qquad\qquad\qquad \All \pred. (I * (I \wand \pred(\void))) \wand \wpre{s}{\pred}
 \end{inbox}} }
{I \proves \wpre{\ewhile{c}{c}{s}}{Q}}

\infer[wp-fst]
{}
{\later \pred(v_1) \proves \wpre{\efst{(v_1, v_2)}}[\mask]{\pred}}

\infer[wp-snd]
{}
{\later \pred(v_2) \proves \wpre{\efst{(v_1, v_2)}}[\mask]{\pred}}

\infer[wp-alloc]
{\tychk{v}{\tau}}
{ (\All l. l \mapsto v : \tau \wand \pred(l) ) \proves \wpre{\ealloc{\tau}{v}}[\mask]{\pred}}

\infer[wp-call]
{}
{ f \tmapsto \Funct(\tau, ps, e) * \ownstack(ks) * \later (\ownstack(k::ks) \wand \wpre{e[ps/ls]}[\mask]{\pred})
  \proves \wpre{k(\ecall{\tau}{f}{ls})}[\mask]{\pred}}

\infer[wp-cas-fail]
{\tychk{v_1}{\tau} \quad \tychk{v_2}{\tau} \quad v_1 \neq v}
{\later l \mapsto_q v : \tau * \later (l \mapsto_q v : \tau \wand \pred(\vfalse))
 \proves \wpre{\eCAS{\tau}{l}{v_1}{v_2}}[\mask]{\pred}}

\infer[wp-cas-suc]
{\tychk{v_1}{\tau} \quad \tychk{v_2}{\tau}}
{\later l \mapsto_q v_1 : \tau * \later (l \mapsto_q v_2 : \tau \wand \pred(\vfalse))
 \proves \wpre{\eCAS{\tau}{l}{v_1}{v_2}}[\mask]{\pred}}

\infer[wp-let]
{}{\later \wpre{e[x/v:\tau]}[\mask]{\pred} \proves \wpre{\elet{\tau}{x}{v}{e}}[\mask]{\pred}}

\end{mathpar}
\caption{WP rules specific to \irisc{}}
\end{figure}

\subsection{Extending Weakest Precondition}\label{def:wpr}

We extend the unary-exit WP into a binary-exit $\wprer{e}[\mask]{\pred}{\predret}$,
by defining it as below:

\begin{align*}
  \textdom{wp}^{+} \eqdef{}& \MU \textdom{wp}^{+}. \Lam \mask, e, \pred, \predret. \\
        & (\Exists v. \toval(e) = v \land \pred(v)) \lor {}\\
        & (\toval(e) = \bot \,\land \Exists e_h, K. e = K(e_h) \land \Bigl({}\\
        &\qquad (\isjmp(e_h) = \FALSE * \wpre{e_h}[\mask]{\Ret v. \wprer{K(v)}[\mask]{\pred}{\predret}}) \lor \\
        &\qquad (\Exists v. e_h = \erete{v} * \later \predret(v)) \lor \\
        &\qquad (\Exists f, ps, ls, F. \\
                           & \qquad \qquad f \tmapsto \Funct(\any, ps, F) * \\
                           & \qquad \qquad \later (\wprer{F[ps/ls]}[\mask]{\Ret\any.\FALSE}{\Ret v.
                             \wprer{K(v)}[\mask]{\pred}{\predret}})) \\
        &\Bigr) )\\
\end{align*}

And this definition supports the following inference rules:

\begin{mathpar}
\infer[wpr-value]{}{\pred(v) \proves \wprer{v}[\mask]{\pred}{\predret}}

\infer[wpr-ret]{}{\predret(v) \proves \wprer{\erete{v}}[\mask]{\pred}{\predret}}

\infer[wpr-bind]
{}
{\wprer\expr[\mask]{\Ret\var. \wprer{k(\var)}[\mask]{\pred}{\predret}}{\predret}
 \proves 
 \wprer{k(\expr)}[\mask]{\pred}{\predret}}

\infer[wpr-seq]
{}
{\wprer{e_1}{\Ret\var. \wprer{\var ; e_2}[\mask]{\pred}{\predret}}{\predret}
 \proves 
 \wprer{e_1; e_2}[\mask]{\pred}{\predret}}

\infer[wpr-call]
{}
{ f \tmapsto \Funct(\tau, ps, e) * \later (\wprer{e[ps/ls]}[\mask]{\Ret\any.\FALSE}{\pred})
  \proves \wprer{k(\ecall{\tau}{f}{ls})}[\mask]{\pred}{\predret}}

\infer[wpr-op]
{\llbracket oplus \rrbracket (v_1, v_2) = v'}
{\pred(v')
 \proves
 \wprer{v_1 \oplus v_2}[\mask]{\pred}{\predret}}

\infer[wp-call-r]
{f \tmapsto \Funct(\tau, ps, e) * \ownstack(ks) *
 \later \wprer{e[ps/ls]}[\mask]{\Ret\any.\FALSE}{\Ret v. \ownstack(ks) * \wpre{k(v)}[\mask]{\pred}} }
{\wpre{k(\ecall{\tau}{f}{ls})}[\mask]{\pred}}

\end{mathpar}

Note how WP-CALL, WP-RET, WP-SEQ, and WP-BIND are simplified in their new, corresponding versions,
also the fact that we can recover local evaluation like WP-OP trivially
(and we won't duplicate too much here).

We also features a rule to compose two styles together freely: WP-CALL-R.

\subsection{Soundness}

The soundness of WP-style program is proven by showing that it is \emph{adequate}: For all $e, \sigma, \pred: \Val \ra \Prop$,

\begin{align*}
&\TRUE \proves \wpre{e}[\top]{\pred} \ra \\
&\quad (\All v, \sigma'. \cstep{e}{\sigma}{v}{\sigma'} \ra \pred(v)) \land \\
&\quad (\All e', \sigma'. \cstep{e}{\sigma}{e'}{\sigma'} \ra (\Exists v. e = v) \lor \red(e', \sigma'))
\end{align*}

(NOTE) However, that doesn't look strong enough.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "iris"
%%% End:

