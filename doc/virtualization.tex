\section{OS and Virtualization}
\label{sec:osvirt}

This section discusses the system features as part of the formalization.
The first part, OS, mainly include interrupt and simulation.
The second part, virtualization, mainly include virtual memory model and
the memory allocator on top of that.

\subsection{Interrupt}

Interrupt is a hardware features, thus we will only write down its abstract specification
without proving it. However, in the OS's perspective, multi-level interrupt will enable us to
open/close OS-global invariants for different level of priorities.

\subsection{Simulation}

Simulation piggybacks on the WP-based program logic through two special kinds of assertions:
spec state witnessing assertion ($\Sstate(\sstate : [X \gmapsto \val])$)
and spec code assertion ($\Scode(\scode)$, more defined below).

\begin{align*}
    \scode : \SpecCode \bnfdef{}&
        \texttt{done}(v?) \mid \texttt{rel}(r: \sstate \ra v? \ra \sstate \ra \Prop) \mid ...
\end{align*}

Then we define specification stepping relationship
$\sstep{\scode}{\sstate}{\scode'}{\sstate'}$:


\begin{mathpar}
\infer[ss-rel]
{\tilde{\sigma_f} \bot \sstate \quad r(\sstate, v, \sstate')}
{\sstep{\texttt{rel}(r)}{\tilde{\sigma_f} \cup \sstate}
  {\texttt{done}(v)}{\tilde{\sigma_f} \cup \sstate'}}
\end{mathpar}

We can also define the reflective transitive closure
$\sstepstar{\scode}{\sstate}{\scode'}{\sstate'}$ trivially.

With this, we can give refinement style proofs for certain kernel APIs.
The following proof rule is proved in Coq:

\begin{mathpar}
\infer[spec-update]
{\sstep{\scode}{\sstate}{\scode'}{\sstate'}}
{\knowInv{\iname}{I_{spec}} * \Sstate(\sstate) * \Scode(\scode)
 \proves \upd \knowInv{\iname}{I_{spec}} * \Sstate(\sstate') * \Scode(\scode')}
\end{mathpar}

\subsection{VMM}

We will first write down the abstract spec for page table primitives:
\texttt{insert}, \texttt{lookup}, and \texttt{delete}. They will change the
locally owned page table content, which is modeled by a \texttt{gmap}.

On top of that, supposing that the physical heap memory is shared across the processes,
and our language provides related operations. We can combine these operation with
page table access to virtualize an exclusively owned, sequentially allocated memory space.
The relevant operations will be \texttt{mem\_init}, \texttt{mem\_read} and \texttt{mem\_write}.

Since our final client is a high-level language, we want to expose an object allocator interface
built on top of the local virtual memory. The new operations for runtime to use will be
\texttt{mem\_alloc}, \texttt{mem\_free}.
\texttt{mem\_init} will be called at the initialization time of the system.
